# -*- coding: utf-8 -*-
"""MC-simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pbs6qWTelsS06wYktRjZslJWMKiz8Sd4

# Monte Carlo Simulation for Portfolio development

This notebook focuses on the use of Monte Carlo Simulation in valuing financial derivatives.

----
"""

import math
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import datetime as dt
import scipy.stats as stats
from pandas_datareader import data as pdr
import yfinance as yf

"""Fetch data"""

end_date = dt.datetime.now()
start_date = end_date - dt.timedelta(days=300)

googl = yf.download('GOOGL', start=start_date, end=end_date)
aapl = yf.download('AAPL', start=start_date, end=end_date)
msft = yf.download('MSFT', start=start_date, end=end_date)
amzn = yf.download('AMZN', start=start_date, end=end_date)
tsla = yf.download('TSLA', start=start_date, end=end_date)

df = pd.concat([googl['Close'], aapl['Close'], msft['Close'], amzn['Close'], tsla['Close']], axis=1)
df

meanReturns = df.pct_change().mean()
covMatrix = df.pct_change().cov()
meanReturns

"""Now we want to define the weights for the portfolio. These weights were determined using a separate notebook, where I calculated the optimal weights along the efficient frontier."""

weights = [0.00087784, 0.57222211, 0.16875112, 0.15750551, 0.10064342]
sum(weights)

"""## Monte Carlo Simulation

We use the Cholesky decomposition to transform uncorrelated samples from a normal distribution into correlated samples that match the covariance structure of the assets in the portfolio. This allows us to simulate realistic asset price paths that respect the observed correlations between the assets.
"""

mc_simulations = 1000
T = 200

meanM = np.full(shape=(T, len(weights)), fill_value=meanReturns)
meanM = meanM.T

portfolio_sims = np.full(shape=(T, mc_simulations), fill_value=0.0)

intialPortfolio = 10000

for i in range(mc_simulations):
  Z = np.random.normal(size=(T, len(weights)))
  L = np.linalg.cholesky(covMatrix)
  dailyReturns = meanM + np.inner(L, Z)
  portfolio_sims[:, i] = np.cumprod(np.inner(weights, dailyReturns.T) + 1) * intialPortfolio

plt.plot(portfolio_sims)
plt.ylabel('Portfolio Value ($)')
plt.xlabel('Days')
plt.show()

import matplotlib.animation as animation

fig, ax = plt.subplots()
ax.set_ylim(portfolio_sims.min(), portfolio_sims.max())
ax.set_xlim(0, T)
ax.set_xlabel('Days')
ax.set_ylabel('Portfolio Value ($)')
ax.grid()

cmap = plt.cm.get_cmap("tab20", mc_simulations)
colors = [cmap(i % 20) for i in range(mc_simulations)]

x = np.arange(T)
lines = []

def animate(i):
    line, = ax.plot(x, portfolio_sims[:, i], color=colors[i % 20], lw=1, alpha=0.8)
    lines.append(line)
    return lines


ani = animation.FuncAnimation(fig, animate, frames=mc_simulations, interval=20, blit=False)
ani.save('portfolio_simulation_colored.gif', writer='imagemagick', fps=30)

plt.show()

import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np

# Create figure and axis
fig, ax = plt.subplots()
ax.set_ylim(portfolio_sims.min(), portfolio_sims.max())
ax.set_xlim(0, T)
ax.set_xlabel('Days')
ax.set_ylabel('Portfolio Value ($)')
ax.grid()

# Set up a colormap
cmap = plt.cm.get_cmap("viridis", mc_simulations)  # Choose a colormap
colors = [cmap(i) for i in range(mc_simulations)]  # Generate a list of colors

x = np.arange(T)
lines = []  # Store line objects

# Animation function
def animate(i):
    # Plot a new line for each frame
    line, = ax.plot(x, portfolio_sims[:, i], color=colors[i], lw=1, alpha=0.7)
    lines.append(line)  # Append the new line to the list of lines
    return lines

# Create the animation
ani = animation.FuncAnimation(fig, animate, frames=mc_simulations, interval=20, blit=False)

# Save the animation as a GIF (optional)
ani.save('portfolio_simulation_incremental.gif', writer='imagemagick', fps=30)

plt.show()