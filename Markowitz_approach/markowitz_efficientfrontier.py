# -*- coding: utf-8 -*-
"""Markowitz_EfficientFrontier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kClwhDHsmQMdg5qkLBBmADI9wJUw-0iH

# Basic Stock Market Analysis & Markowitz Efficient Frontier

In simple terms, if we have a set of stocks one could be interested investing in, we can use the Markowitz Optimization problem to allocate the funds to achieve the lowest amount of risk.
"""

import pandas_datareader.data as web
import yfinance as yf
import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Set up time-window for which one wants to analyze the asset/stocks
start_date = datetime.datetime(2023, 1, 1)
end_date = datetime.datetime(2023, 12, 31)

"""In the next phase, one needs to look into which kind of stocks that are interesting and potentially want to invest in"""

# Sample some stocks from the S&P 500
tickers = ['AAPL', 'MSFT', 'GOOG', 'AMZN', 'TSLA']

googl = yf.download('GOOGL', start=start_date, end=end_date)
aapl = yf.download('AAPL', start=start_date, end=end_date)
msft = yf.download('MSFT', start=start_date, end=end_date)
amzn = yf.download('AMZN', start=start_date, end=end_date)
tsla = yf.download('TSLA', start=start_date, end=end_date)

# Fetch closing price for each stock and concatinate into one dataframe
df = pd.concat([googl['Close'], aapl['Close'], msft['Close'], amzn['Close'], tsla['Close']], axis=1)
df

df = df.reset_index()
df

print(df.columns)
df = df.rename_axis(None, axis=1)
df

df['Date'] = pd.to_datetime(df['Date']).dt.date

df.set_index('Date', inplace=True)
df

"""With the dataframe now cleaned up, we want to compute the returns which is done using the following formula:

$$r_{t} = \frac{p_{t}}{p_{t-1}}$$
"""

returns = df/df.shift(1)
returns

"""### Log-Returns

We now use the log-returns which can be defined by:

$$\log{r_{t}} = \log{\frac{p_{t}}{p_{t-1}}}$$

We use this to scale the returns, which through this gives a more fair representation of the actual returns.
"""

returns = returns.dropna()
logReturns = np.log(returns)
logReturns

"""### Sharpe Ratio

The sharpe ratio is a ratio which is correspondent to the portfolio that we are looking into, and is defined as follows:

$$SR(w) = \frac{R(w)-R_f}{\sigma(w)}$$

$$w = [w_1 w_2 w_3 w_4 w_5]$$


The weights, $w$ shows us how much of the budget we should allocate to each stock. The sum of all the weights, $w_{1->5}$, should equal 1.

Since we are looking for max($SR(w)$) and $R_f$ is common for all $w$'s, then we shall compute:

$$R(w) = w^{T} \cdot \log{(r)}$$

$$\sigma(w) = \sqrt{w^{T} \cdot cov(w)}$$

$$SR(w) \sim  \frac{w^{T} \cdot \log{(r)}}{\sqrt{w^{T} \cdot cov(w)}}$$

### Return vs. Volatility Chart
Want to generate as many different portfolios as possible in order to see which one that is the best.
"""

# We chose a random number of portfolios we want to investigate
n_portfolios = 1000000
weight_v = np.zeros((n_portfolios, len(tickers)))
returns_v = np.zeros(n_portfolios)
risk_v = np.zeros(n_portfolios)
sharpe_v = np.zeros(n_portfolios)

# For faster computation
meanlogReturn = logReturns.mean() * 252
covMatrix = logReturns.cov() * 252

for i in range(n_portfolios):
    weights = np.random.random(len(tickers))
    weights /= np.sum(weights)
    weight_v[i, :] = weights

    ## Now we want to compute the Sharpe Ratio ##

    # expected log-return
    returns_v[i] = np.sum(meanlogReturn * weights)
    # expected volatility
    risk_v[i] = np.sqrt(np.dot(weights.T, np.dot(covMatrix, weights)))
    # sharpe ratio
    sharpe_v[i] = returns_v[i] / risk_v[i]

"""Now we want **Sharpe Ratio Maximization**"""

maxIndex = sharpe_v.argmax()
print(maxIndex)

weight_v[maxIndex, :]

"""Now we want to create a scatterplot in which we plot the returns vs. volatility."""

plt.figure(figsize=(20, 6))
plt.scatter(risk_v, returns_v, c=sharpe_v, cmap='plasma')
plt.colorbar(label='Sharpe Ratio')
plt.scatter(risk_v[maxIndex], returns_v[maxIndex], c='red', s=50, edgecolors='black')
plt.title('Efficient Frontier')
plt.xlabel('Volatility')
plt.ylabel('Returns')

"""## Efficient Markowitz Frontier

Want to minimize the following:

$$\text{minimize}_{w} \quad w^{T} \Sigma w$$

Subject to the following constraints:
$$\mathbf{p}^{T} w \geq r_{\text{min}}$$
$$w \geq 0$$
$$1^{T} w = 1$$

This can be rewritten as the following:

$$\text{minimize}_{w} \quad SR(w)$$

Subject to the following constraints:
$$0 \leq w_i \leq 1, \quad i=1...5$$
"""

def negative_sharpe(weights):
  w = np.array(weights)
  R = np.sum(meanlogReturn * w)
  V = np.sqrt(np.dot(w.T, np.dot(covMatrix, w)))
  return -R/V

w0 = [0.2, 0.2, 0.2, 0.2, 0.2]
bounds = ((0, 1) for i in range(len(tickers)))
constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})

from scipy.optimize import minimize
w_opt = minimize(negative_sharpe, w0, method='SLSQP', bounds=bounds, constraints=constraints)
w_opt

w_opt.x

"""We see that using the Markowitz approach converges towards similar values but in a faster fashion."""